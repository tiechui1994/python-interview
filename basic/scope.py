"""
作用域搜索:
    local(局部作用域)->enclosing(函数范围作用域)->global(全局作用域)->build-in(内建对象作用域)
"""

i = 0


def read_global_var():
    print(i)


def update_global_var():
    """
    使用global, 引入全局变量, 并且可以修改之 (找不到会引发NameError)
    使用nonlocal, 引用局部上层变量, 并且可以修改之 (找不到会引发SyntaxError)
    """
    i += 1  # i = i + 1, 第一个i表示在函数作用域绑定变量名称i, 第二个i, 搜索局部范围的的变量名称i
    # 并且找到,但是却没有初始化, 抛出异常(UnboundLocalError)
    print(i)  # 同上描述


def use_before_init():
    """先声明, 然后在使用"""
    print(t)  # 变量t是局部变量,可以查找到, 但次数还未初始化,它还未被绑定到任何对象之上,所以抛出
    # 异常(UnboundLocalError)
    t = 0


"""
对于模块代码而言,代码在执行之前,没有经过什么预处理,但是对于函数体而言,代码在运行之前已经经过了一个
预处理,因此不论名字绑定发生在作用域的哪个位置,它都能感知出来.Python虽然是一个静态作用域语言,但是名
字查找确实动态发生的,因此直到运行的时候,才会发现名字方面的问题.

名称的绑定(确定名称作用域)
    名称引用对象.名称由名称绑定操作引入.(名字绑定在所属作用域中引入新的变量,同时绑定到一个对象)
    下面结构将会绑定名称：
        1.参数声明:参数声明在函数的局部作用域中引入新的变量;
        2.赋值操作:对一个变量进行初次赋值会在当前作用域中引入新的变量,后续赋值操作则会重新绑定该变量;
        3.类和函数定义(绑定类或函数的名称于定义它们的代码块中):类和函数定义将类名和函数名作为变量引入
    当前作用域,类体和函数体将形成另外一个作用域;
        4.import语句:import语句在当前作用域中引入新的变量,一般是在全局作用域;
        5.for语句:for语句在当前作用域中引入新的变量(循环变量);
        6.with语句和except子句中as后面的内容:with语句和except语句在当前作用域中引入新的变量(异常对象).

        注: from ... import *形式的import语句绑定导入的模块中定义的所有名称,除了以下划线(_)开头的
    那些.这种形式只能在模块级别使用.

    每个赋值和导入语句出现在类或函数定义的代码块中或者出现在模块级别(顶级代码块). // 说明情况

    如果名称在一个代码块中绑定,那么它是该代码块的一个局部变量,除非声明为nonlocal或者global.
    如果一个名称绑定在模块级别,那么它是一个全局变量.(定义在模块中的变量既是局部变量也是全局变量.)
    如果一个变量在代码块中只使用但未定义,那么它是一个自由变量.(自由变量的名称解析发生在运行时刻，
    不是在编译时刻)


名称的解析(确定运行时名称的值)
    作用域定义一个代码块中名称的可见性. 如果一个局部变量在一个代码块中定义,那么它的作用域包括那个代码块;
    如果定义出现在函数代码块中,那么其作用域扩展到这个函数代码块中包含的任何代码块,除非某个被包含的代码块为
    该名称引入一个不同的绑定.

    当一个名称在代码块中使用时,它使用包含它最近的作用域解析.对于一个代码块所有可见作用域的集合称做代码块的环境.

    异常:
        当一个名称完全找不到是,将引发一个NameError异常.
        如果当前的作用域是一个函数作用域,而且名称引用一个局部变量,这个变量在该名称使用的时候还没有绑定到一
    个值,则引发一个UnboundLocalError异常(UnboundLocalError是NameError的子类).

    如果在代码块的任意地方出现名称绑定操作,那么代码块中该名称的所有使用将被当做对当前代码块的引用.
    当名称在一个代码块中绑定之前使用时将导致错误.
    代码块的局部变量是通过扫描代码块的全部文本的名称绑定操作决定.

    global的运行机制和作用域规则:
        如果global语句出现在代码块内,在语句中指定的名称的所有引用都是指该名称在的顶级命名空间中的绑定.
        名称在顶级命名空间中的解析通过搜索全局命名空间,即包含该代码块的模块的命名空间,和内建的命名空间(模
    块builtins的命名空间).
        首先查找全局命名空间,如果那里找不到名称,就会查找内建的命名空间.
        global语句必须位于该名称的所有引用之前.

        global语句的作用域与同一代码块中的名称绑定操作相同(局部范围可以操作上层的变量).如果包含自由变量
    的最内层定义域包含一条global语句,那么这个自由变量[声明式变量]被认为是一个全局变量.

    nonlocal的作用域规则
        nonlocal语句使得对应的名称引用在最靠近的包含它的函数的作用域中绑定的变量. 但是可以操作上层的变量
        如果给定的名称在任何包含它的函数的作用域中都找不到,则在编译时刻引发SyntaxError.

    模块的命名空间在模块第一次导入时自动创建.脚本的主模块始终叫做__main__.

    类定义以及exec()和eval()的参数在名称解析的上下文中比较特殊.
    类定义是一条可以使用和定义名称的可执行语句.这些引用遵循正常的名称解析规则,
    除了一个例外,就是未绑定的局部变量在全局作用域中查找.类定义的命名空间变成类的属性字典.
    在类代码块中定义的名称的作用域限制在类代码块中; 它不会延伸到方法的代码块中 —— 包括解析式和生成器表达式,
    因为它们是使用函数作用域实现的.也就是说下面这段代码执行会失败:

    class A:
        a = 42
        b = list(a + i for i in range(10))


在Python中,类定义所引入的作用域对于成员函数是不可见的,这与C++或者Java是很不同的,因此在Python中,
成员函数想要引用类体定义的变量,必须通过self或者类名来引用它.

嵌套作用域的加入,会导致一些代码编译不过或者得到不同的运行结果,在这里Python解释器会帮助你识别这些
可能引起问题的地方,给出警告.

locals函数返回所有的局部变量,但是不会返回嵌套作用域中的变量,实际上没有函数会返回嵌套作用域中的变量
"""
x = 10
a = lambda: x


def say():
    return x


b = say

print(a.__code__.co_code == b.__code__.co_code)  # 代码等价

"""
for语句:for语句在当前作用域中引入新的变量(循环变量)
Python名字绑定发生在作用域的哪个位置,它都能感知出来
"""
li = [lambda: j for j in range(10)]
print(len(li))  # 10
print(li[0]())  # 9
print(li[0].__closure__[0].cell_contents)
print(li[0].__code__.co_freevars)  # 闭包使用的变量名集合

"""
参数声明:参数声明在函数的局部作用域中引入新的变量
for语句:for语句在当前作用域中引入新的变量(循环变量) <-
"""


def fn(var):
    for var in [0, 1, 2]:
        var += 1
    print(var)


fn('uu')  # 输出结果总是3


def function():
    age = 20

    def inner():
        global age  # 声明式语句, 如果顶级命名空间中绑定了age,则与age绑定, 否则仅仅是声明了一个变量age(不能使用)
        # age = 1000  将age与1000绑定,此时的age是全局变量, 作用域是全局, 局部可以操作
        print(age)  # 运行时候报错, global是顶级命名空间中名称的绑定, 如果不存在,则抛出异常NameError

    return inner


"""
NameError与UnboundLocalError
"""


def check_name_not_exsit_exception():
    def name_error():
        print(z)

    def unbound_local_error():
        print(q)
        q = 10

    try:
        name_error()
    except NameError as e:
        print(e, type(e))

    try:
        unbound_local_error()
    except UnboundLocalError as e:
        print(e, type(e))


check_name_not_exsit_exception()

g = 10


def say():
    p = 10

    def inner():
        nonlocal p
        p += 100
        print(p)

    return inner


say()()
